**Аналіз результатів:**

На основі отриманих результатів, ми зможемо підтвердити теоретичні оцінки складності алгоритмів:

1. **Алгоритм злиттям (Merge Sort)**: складність O(n log n), досить швидкий на великих наборах даних.
2. **Алгоритм вставками (Insertion Sort)**: складність O(n^2), підходить для малих масивів, але значно повільніший на великих наборах даних.
3. **Timsort**: складність O(n log n) у середньому випадку, але завдяки поєднанню з сортуванням вставками, він показує кращу продуктивність на реальних даних.

---

**Висновки:**

З отриманих результатів можна зробити висновок, що поєднання сортування злиттям і сортування вставками в алгоритмі Timsort робить його значно ефективнішим на практиці. Це підтверджує, чому програмісти використовують вбудовані функції сортування в Python, такі як `sorted`, замість того, щоб писати власні реалізації алгоритмів. Timsort оптимізований для реальних задач і показує високу продуктивність у різних ситуаціях.

1. **Алгоритм сортування злиттям (Merge Sort):**
   - Показує складність O(n log n).
   - Час виконання збільшується пропорційно до розміру масиву.
   - На великих масивах цей алгоритм значно ефективніший за сортування вставками, але все ще поступається Timsort.

2. **Алгоритм сортування вставками (Insertion Sort):**
   - Підтверджує свою теоретичну складність O(n^2).
   - Ефективний на малих масивах, але дуже повільний на великих масивах.
   - При розмірі масиву 10000, час виконання майже 2.72 секунди, що робить його непридатним для великих обсягів даних.

3. **Timsort (вбудована функція `sorted`):**
   - Показує найкращі результати на всіх тестованих масивах.
   - Завдяки поєднанню сортування злиттям і сортування вставками, Timsort демонструє складність O(n log n) у середньому випадку.
   - Емпіричні дані підтверджують високу продуктивність Timsort навіть на великих масивах.s
